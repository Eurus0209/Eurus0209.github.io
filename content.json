{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"会飞","url":"http://yoursite.com","root":"/"},"pages":[{"title":"life","date":"2019-10-31T05:00:23.000Z","updated":"2019-10-31T05:01:20.465Z","comments":true,"path":"life/index.html","permalink":"http://yoursite.com/life/index.html","excerpt":"","text":""},{"title":"Hi 我是会飞","date":"2019-10-31T02:38:14.000Z","updated":"2019-10-31T05:17:46.131Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"try"}],"posts":[{"title":"数据结构-堆栈","slug":"数据结构-堆栈","date":"2019-11-01T06:36:38.000Z","updated":"2019-11-01T07:38:06.840Z","comments":true,"path":"2019/11/01/数据结构-堆栈/","link":"","permalink":"http://yoursite.com/2019/11/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86%E6%A0%88/","excerpt":"","text":"堆栈的抽象数据类型描述 栈的顺序存储实现1234567#define maxsizetypedef struct SNode *Stack;struct SNode&#123; ElementType Data[maxsize]; int Top&#125;;Stack Ptrs; 主要操作实现入栈1234567891011void Push(Stack PtrS, ElementType item)&#123; if(PtrS-&gt;Top == maxsize -1) &#123; printf(\"堆栈满\"); return; &#125;else&#123; PtrS-&gt;Data[++(PtrS-&gt;Top)] = item; return; &#125;&#125; 出栈12345678910ElementType Pop(Stack PtrS)&#123; if(PtrS-&gt;Top == -1) &#123; printf(\"堆栈空\"); return ERROR; //ERROR是特数值，标志错误 &#125; else return (PtrS-&gt;Data[(PtrS-&gt;Top)--]);&#125; 数组实现两个堆栈用一个数组实现两个堆栈，要求最大的利用数组空间，使数组只要有空间入栈操作就可以成功。 12345678#define maxsizestruct DStack&#123; ElementType Data[maxsize]; int Top1; //堆栈1的栈顶指针 int Top2; //堆栈2的栈顶指针&#125;S;S.Top1 = -1; // 在0里S.Top2 = maxsize; // 在maxsize-1外 入栈12345678910111213void Push(struct DStack *PtrS, ElementType item, int Tag)&#123; //Tag作为区分两个堆栈的标志 1 或 2 if (PtrS-&gt;Top2 - PtrS-&gt;Top1 ==1) &#123; printf(\"堆栈满\"); return ; &#125; if (Tag==1) PtrS -&gt; Data[++(PtrS-&gt;Top1)] = item; else PtrS -&gt; Data[--(PtrS-&gt;Top2)] = item; &#125; 出栈12345678910111213141516171819ElementType Pop(struct DStack *PtrS, int Tag)&#123; if (Tag==1) &#123; if(PtrS-&gt;Top1 == -1) &#123; printf(\"堆栈1空\"); return NULL; &#125; else return PtrS-&gt;Data[(PtrS-&gt;Top1)--]; &#125; else &#123; if (PtrS-&gt;Top2 == maxsize) &#123; printf(\"堆栈2空\"); return NULL; &#125; else return PtrS-&gt;Data[(PtrS-&gt;Top2)++]; &#125;&#125; 堆栈链式存实现栈的链式存储结构实际上就是一个单链表，叫做链栈。 插入和删除操作只能在链栈的栈顶进行。栈顶指针Top应该在链表的头部。 123456typedef struct SNode *Stack;struct SNode&#123; ElementType Data; struct SNode *Next;&#125;; 堆栈初始化1234567Stack CreateStack()&#123; //构建一个堆栈的头结点，返回指针 Stack S; S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Next = NULL; return S;&#125; 判断堆栈是否为空1234int IsEmpty(Stack S)&#123; return (S-&gt;Next == NULL);&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"线性结构","slug":"线性结构","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"}]},{"title":"19-11-01 杂记","slug":"19-11-01-杂记","date":"2019-11-01T06:13:55.000Z","updated":"2019-11-01T06:17:52.694Z","comments":true,"path":"2019/11/01/19-11-01-杂记/","link":"","permalink":"http://yoursite.com/2019/11/01/19-11-01-%E6%9D%82%E8%AE%B0/","excerpt":"","text":"昨儿晚上睡觉前，室友突然发现，已经11月了，再过一个月，2019年就结束了。害，明年就都20岁了，一点都不像20岁的样子，离自己理想的自己差的还可远了呢。 最近把博客搞了出来，说实话技术含量不大，想往后学学能把每一个文件夹里的东西都给搞懂，再做些自己的东西吧。","categories":[{"name":"个人","slug":"个人","permalink":"http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"数据结构-广义表","slug":"数据结构-广义表","date":"2019-10-31T15:04:24.000Z","updated":"2019-11-01T06:36:06.617Z","comments":true,"path":"2019/10/31/数据结构-广义表/","link":"","permalink":"http://yoursite.com/2019/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%BF%E4%B9%89%E8%A1%A8/","excerpt":"","text":"结构123456789typedef struct GNode *GList;struct GNode&#123; int Tag; //标志域：0表示结点是单元素，1表示结点是广义表 union&#123; //子表指针域Sublist与单元素数据域Data复用 ElementType Data; GList SubList; &#125; URegion; GList Next; //指向后继结点&#125;; 多重链表 例子矩阵可以用二维数组表示，但二维数组表示有两个缺陷 数组大小要事先确认 对于“稀疏矩阵”，造成大量的存储空间浪费。 分析： 只存储矩阵非0元素项 结点的数据域：行坐标Row，列坐标Col，数值Value 每个结点通过两个指针域，把同行、同列串起来 行指针（向右指针） Right 列指针（向下指针） Down *term 4 5 7 *: 路口结点，四行五列七项非零项 用一个标识符Tag来区分头结点和非0元素结点 头结点的标识值为”Head”，矩阵非0元素结点的标识值为”Term”.","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"线性结构","slug":"线性结构","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"}]},{"title":"牛客网PAT-B练习 1002 NowCoder数列","slug":"牛客网PAT-B练习-1002-NowCoder数列","date":"2019-10-31T06:13:48.000Z","updated":"2019-10-31T06:21:12.434Z","comments":true,"path":"2019/10/31/牛客网PAT-B练习-1002-NowCoder数列/","link":"","permalink":"http://yoursite.com/2019/10/31/%E7%89%9B%E5%AE%A2%E7%BD%91PAT-B%E7%BB%83%E4%B9%A0-1002-NowCoder%E6%95%B0%E5%88%97/","excerpt":"题目描述12345NowCoder最近在研究一个数列：* F(0) = 7* F(1) = 11* F(n) = F(n-1) + F(n-2) (n≥2)他称之为NowCoder数列。请你帮忙确认一下数列中第n个数是否是3的倍数。","text":"题目描述12345NowCoder最近在研究一个数列：* F(0) = 7* F(1) = 11* F(n) = F(n-1) + F(n-2) (n≥2)他称之为NowCoder数列。请你帮忙确认一下数列中第n个数是否是3的倍数。 输入描述12输入包含多组数据。每组数据包含一个整数n，(0≤n≤1000000)。 输出描述12对应每一组输入有一行输出。如果F(n)是3的倍数，则输出“Yes”；否则输出“No”。 输入数据123456012345 输出数据123456NoNoYesNoNoNo 我的思路 为避免重复操作，先读入所有的数并找到最大值max，定义一个函数求出包含前max+1项的数组。 关于终止输入：每个数后面都有一个空格，当读入数据后没有空格时，则跳出while循环终止输入。 我的代码：（报错，原因未知） 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;void Nowcoder(int m, int *a)&#123; int i=0; for(i=0;i&lt;=m;i++) &#123; if (i==0) a[i]=7; else if (i==1) a[i]=11; else a[i]=a[i-1]+a[i-2]; &#125;&#125;int main()&#123; int a[10000]=&#123;0&#125;; int b[10000]; int n,i=0,max=-1; while(scanf(\"%d\",&amp;n)) &#123; b[i++]=n; if(b[i-1]&gt;max) max=b[i-1]; char ch; if ((ch=getchar())!=' ') break; &#125; Nowcoder(max,a); int j=i; for(i=0;i&lt;j;i++) &#123; if(a[b[i]]%3==0) printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125;&#125; 大佬思路1234567题目中的公式为F(n)=F(n-1)+F(n-2)模拟规律得:F(2)=F(1)+F(0)=11+7=18 可以整除F(3)=F(2)+F(1)=18*1+11*1 不可以被整除F(4)=F(3)+F(2)=18*2+11*1 不可以被整除F(5)=F(4)+F(3)=18*3+11*2 不可以被整除F(6)=F(5)+F(4)=18*5+11*3 可以整除以此类推可以发现数列最终是求11出现的个数即只要11出现3倍的时候才能被整除，正好n=2,6,10,14......能被3整除 即n%4==2的即可被3整除。 解法: 123456789101112#include &lt;stdio.h&gt;int main()&#123; int n; while (scanf(\"%d\", &amp;n) != EOF) &#123; if (n % 4 == 2) printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"PAT-B","slug":"PAT-B","permalink":"http://yoursite.com/tags/PAT-B/"}]},{"title":"数据结构-线性表","slug":"数据结构-线性表","date":"2019-10-30T15:34:24.000Z","updated":"2019-11-01T06:30:44.756Z","comments":true,"path":"2019/10/30/数据结构-线性表/","link":"","permalink":"http://yoursite.com/2019/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"线性表 线性表的抽象数据类型描述 线性表的顺序存储实现 123456789typedef struct LNode *List;struct LNode&#123; ElementType Data[max]; int Last;&#125;;struct LNode L;List PtrL; //访问下标为i的元素：L.Data[i] / PtrL -&gt; Data[i]//线性表的长度： L.Last+1 / PtrL-&gt;Last +1 主要操作实现初始化（建立空的顺序表）1234567List MakeEmpty()&#123; List PtrL; //list为指向结构的指针类型 PtrL = (List)malloc(sizeof(struct LNode)); PtrL -&gt; Last = -1; return PtrL;&#125; 查找12345678910int Find(ElementType X, List PtrL)&#123; int i = 0; while(i &lt;= PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i]!= X) i++; if(i &gt; PtrL-&gt;Last) return -1; //没找到 返回-1 else return i; //找到后 返回位置&#125; 插入 从后面开始挪 12345678910111213141516171819void Insert(ElementType X,int i, List PtrL)&#123; int j; if(PtrL-&gt;Last == maxsize -1) //空间已满 &#123; printf(\"表满\"); return; &#125; if (i&lt;1 || i&gt;PtrL-&gt;Last+2) //插入位置合法性 &#123; printf(\"位置不合法\"); return; &#125; for(j=PtrL-&gt;Last; j&gt;= i-1; j--) PtrL-&gt;Data[j+1] = PtrL-&gt;Data[j];//向后挪 PtrL-&gt;Data[i-1]=X; //新元素插入 PtrL-&gt;Last++; //Last指向最后元素 return;&#125; 删除（删除表的第i个位置上的元素） 12345678910111213void Delete(int i, List PtrL)&#123; int j; if(i&lt;1 || i&gt;PtrL-&gt;Last+1) &#123; printf(\"不存在第%d个元素\",i); return; &#125; for(j=i;j&lt;=PtrL-&gt;Last;j++) PtrL-&gt;Data[j-1]=PtrL-&gt;Data[j]; PtrL-&gt;Last--; return;&#125; 线性表的链式存储结构 1234567typedef struct LNode *List;struct LNode&#123; ElementType Data; List Next; //下一个序号&#125;;struct LNode L;List PtrL; 主要操作实现求表长把链表遍历一遍 123456789101112int Length(List PtrL)&#123; List p =PtrL; //p指向表的第一个结点 int j = 0; while(p) //p != NULL 时 &#123; p = p-&gt;Next; j++; //当前p指向的是第j个结点 &#125; return j;&#125;//时间复杂度：O(n) 查找 按序号查找：FindKth; 1234567891011121314List FindKth(int K, List PtrL)&#123; List p = PtrL; int i =1; while(p!=NULL &amp;&amp; i&lt;K) &#123; p = p-&gt;Next; i++; &#125; if (i==K) return p; else return NULL;&#125; 按值查找：Find 1234567List Find(ElementType X, List PtrL)&#123; List p = PtrL; while(p!=NULL &amp;&amp; p-&gt;Data != X) p = p-&gt;Next; return p;&#125; 插入（在i-1个结点后插入X） 1234567891011121314151617181920212223List Insert(ElementType X, int i, List PtrL)&#123; List p,s; if(i==1) //插在表头时 &#123; s = (List)malloc(sizeof(struct LNode)); s-&gt;Data = X; s-&gt;Next = PtrL; return s; //返回一个新的链表 &#125; p = FindKth(i-1,PtrL); if(p==NULL) &#123; printf(\"参数错\"); return NULL; &#125;else &#123; s=(List)malloc(sizeof(struct LNode)); s-&gt;Data = X; s-&gt;Next = p-&gt;Next; p-&gt;Next = s; return PtrL; &#125;&#125; 删除（删除链表第i个位置上的结点） （4）重要：free(s) 12345678910111213141516171819202122232425262728List Delete(int i,List PtrL)&#123; List p,s; if(i==1) &#123; s=PtrL; if(PtrL!=NULL) PtrL = PtrL-&gt;Next; else return NULL; free(s); return PtrL; &#125; p = findKth(i-1,PtrL); if(p==NULL) &#123; printf(\"第%d个结点不存在\",i-1); return NULL; &#125;else if(p-&gt;Next == NULL) &#123; printf(\"第%d个结点不存在\", i); &#125;else&#123; s = p-&gt;Next; p-&gt;Next = s-&gt;Next; free(s); return PtrL; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"线性结构","slug":"线性结构","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"}]}]}