{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"数据结构-线性表","slug":"数据结构-线性表","date":"2019-10-30T15:34:24.000Z","updated":"2019-10-30T15:36:58.798Z","comments":true,"path":"2019/10/30/数据结构-线性表/","link":"","permalink":"http://yoursite.com/2019/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"线性表 线性表的抽象数据类型描述 线性表的顺序存储实现 123456789typedef struct LNode *List;struct LNode&#123; ElementType Data[max]; int Last;&#125;;struct LNode L;List PtrL; //访问下标为i的元素：L.Data[i] / PtrL -&gt; Data[i]//线性表的长度： L.Last+1 / PtrL-&gt;Last +1 主要操作实现 初始化（建立空的顺序表） 1234567List MakeEmpty()&#123; List PtrL; //list为指向结构的指针类型 PtrL = (List)malloc(sizeof(struct LNode)); PtrL -&gt; Last = -1; return PtrL;&#125; 查找 12345678910int Find(ElementType X, List PtrL)&#123; int i = 0; while(i &lt;= PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i]!= X) i++; if(i &gt; PtrL-&gt;Last) return -1; //没找到 返回-1 else return i; //找到后 返回位置&#125; 插入 从后面开始挪 12345678910111213141516171819void Insert(ElementType X,int i, List PtrL)&#123; int j; if(PtrL-&gt;Last == maxsize -1) //空间已满 &#123; printf(\"表满\"); return; &#125; if (i&lt;1 || i&gt;PtrL-&gt;Last+2) //插入位置合法性 &#123; printf(\"位置不合法\"); return; &#125; for(j=PtrL-&gt;Last; j&gt;= i-1; j--) PtrL-&gt;Data[j+1] = PtrL-&gt;Data[j];//向后挪 PtrL-&gt;Data[i-1]=X; //新元素插入 PtrL-&gt;Last++; //Last指向最后元素 return;&#125; 删除（删除表的第i个位置上的元素） 12345678910111213void Delete(int i, List PtrL)&#123; int j; if(i&lt;1 || i&gt;PtrL-&gt;Last+1) &#123; printf(\"不存在第%d个元素\",i); return; &#125; for(j=i;j&lt;=PtrL-&gt;Last;j++) PtrL-&gt;Data[j-1]=PtrL-&gt;Data[j]; PtrL-&gt;Last--; return;&#125; 线性表的链式存储结构 1234567typedef struct LNode *List;struct LNode&#123; ElementType Data; List Next; //下一个序号&#125;;struct LNode L;List PtrL; 主要操作实现 求表长 把链表遍历一遍 123456789101112int Length(List PtrL)&#123; List p =PtrL; //p指向表的第一个结点 int j = 0; while(p) //p != NULL 时 &#123; p = p-&gt;Next; j++; //当前p指向的是第j个结点 &#125; return j;&#125;//时间复杂度：O(n) 查找 按序号查找：FindKth; 1234567891011121314List FindKth(int K, List PtrL)&#123; List p = PtrL; int i =1; while(p!=NULL &amp;&amp; i&lt;K) &#123; p = p-&gt;Next; i++; &#125; if (i==K) return p; else return NULL;&#125; 按值查找：Find 1234567List Find(ElementType X, List PtrL)&#123; List p = PtrL; while(p!=NULL &amp;&amp; p-&gt;Data != X) p = p-&gt;Next; return p;&#125; 插入（在i-1个结点后插入X） 1234567891011121314151617181920212223List Insert(ElementType X, int i, List PtrL)&#123; List p,s; if(i==1) //插在表头时 &#123; s = (List)malloc(sizeof(struct LNode)); s-&gt;Data = X; s-&gt;Next = PtrL; return s; //返回一个新的链表 &#125; p = FindKth(i-1,PtrL); if(p==NULL) &#123; printf(\"参数错\"); return NULL; &#125;else &#123; s=(List)malloc(sizeof(struct LNode)); s-&gt;Data = X; s-&gt;Next = p-&gt;Next; p-&gt;Next = s; return PtrL; &#125;&#125; 删除（删除链表第i个位置上的结点） （4）重要：free(s) 12345678910111213141516171819202122232425262728List Delete(int i,List PtrL)&#123; List p,s; if(i==1) &#123; s=PtrL; if(PtrL!=NULL) PtrL = PtrL-&gt;Next; else return NULL; free(s); return PtrL; &#125; p = findKth(i-1,PtrL); if(p==NULL) &#123; printf(\"第%d个结点不存在\",i-1); return NULL; &#125;else if(p-&gt;Next == NULL) &#123; printf(\"第%d个结点不存在\", i); &#125;else&#123; s = p-&gt;Next; p-&gt;Next = s-&gt;Next; free(s); return PtrL; &#125;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}]}