{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"会飞","url":"http://yoursite.com","root":"/"},"pages":[{"title":"life","date":"2019-10-31T05:00:23.000Z","updated":"2019-10-31T05:01:20.465Z","comments":true,"path":"life/index.html","permalink":"http://yoursite.com/life/index.html","excerpt":"","text":""},{"title":"Hi 我是会飞","date":"2019-10-31T02:38:14.000Z","updated":"2019-10-31T05:17:46.131Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"try"}],"posts":[{"title":"排序算法","slug":"排序算法","date":"2019-11-27T13:45:19.311Z","updated":"2019-11-28T13:19:24.740Z","comments":true,"path":"2019/11/27/排序算法/","link":"","permalink":"http://yoursite.com/2019/11/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"简单排序冒泡排序1234567891011121314void Bubble_Sort (ElementType A[], int N)&#123; for(int P= N-1; P&gt;=0; P--)&#123; int flag = 1; for (i=0; i&lt;P; i++)&#123; if(A[i] &gt; A[i+1])&#123; swap(A[i],A[i+1]); flag = 0; &#125; &#125; if(flag) break; &#125;&#125; 最好情况： 顺序 T = O(N) 最坏情况： 逆序 T = O(N^2^) 插入排序12345678910void Insertion_Sort (ElementType A[], int N)&#123; int i, P; for (P=1; P&lt;N; P++)&#123; Tmp = A[P]; //下一张牌 for(i=P; i&gt;0 &amp;&amp; A[i-1]&gt;Tmp; i--) A[i] = A[i-1]; //移出空位 A[i] = Tmp; //新牌落位 &#125;&#125; 最好情况： 顺序 T = O(N) 最坏情况： 逆序 T = O(N^2^) 时间复杂度下界 插入排序： T(N, I) = O(N+I) N: 元素个数， I：逆序对个数 希尔排序​ 归并排序(Merge_Sort)递归实现1234567891011121314151617181920212223242526272829303132333435363738394041424344//L=左边起始位置, R=右边起始位置, RightEnd=右边终点位置void Merge(ElementType A[], ElementType TmpA[], int L, int R, int RightEnd)&#123; int LeftEnd = R-1; //左边终点位置 int Tmp = L; //存放结果的数组的初始位置 int NumElements = RightEnd - L + 1; while (L&lt;=LeftEnd &amp;&amp; R&lt;=RightEnd)&#123; if (A[L] &lt;= A[R]) TmpA[Tmp++] = A[L++]; else TmpA[Tmp++] = A[R++]; while (L&lt;=LeftEnd) TmpA[Tmp++] = A[L++]; while (R&lt;=RightEnd) TmpA[Tmp++] = A[R++]; for(int i=0; i&lt;NumElements; i++, RightEnd--) A[RightEnd] = Tmp[RightEnd]; &#125;&#125;void Msort (ElementType A[], ElementType TmpA[],int L, int RightEnd)&#123; int Center; if(L&lt;RightEnd)&#123; Center = (L+RightEnd)/2; Msort(A,TmpA, L,Center); Msort(A,TmpA, Center+1, RightEnd); Merge(A,TmpA, L, Center+1, RightEnd); &#125;&#125;void Merge_Sort (ElementType A[], int N)&#123; ElementType *TmpA; TmpA = (ElementType *)malloc(N*sizeof(ElementType)); if(TmpA!=NULL)&#123; Msort(A,TmpA,0,N-1); free(TmpA); &#125;else printf(\"空间不足\");&#125; 循环实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void Merge(ElementType A[], ElementType TmpA[], int L, int R, int RightEnd)&#123; int LeftEnd = R-1; //左边终点位置 int Tmp = L; //存放结果的数组的初始位置 int NumElements = RightEnd - L + 1; while (L&lt;=LeftEnd &amp;&amp; R&lt;=RightEnd)&#123; if (A[L] &lt;= A[R]) TmpA[Tmp++] = A[L++]; else TmpA[Tmp++] = A[R++]; while (L&lt;=LeftEnd) TmpA[Tmp++] = A[L++]; while (L&lt;=RightEnd) TmpA[Tmp++] = A[R++]; for(int i=0; i&lt;NumElements; i++, RightEnd--) A[RightEnd] = Tmp[RightEnd]; &#125;&#125;void Merge_pass (ElementType A[],ElementType TmpA[], int N, int length)&#123; //两两归并相邻有序子列 int i,j; for(i=0;i&lt;N-2*length; i+= 2*length) Merge(A, TmpA, i, i+length, i+2*length-1); if(i+length &lt;N) Merge(A, TmpA, i, i+lenght, N-1); else for(j=i; j&lt;N; j++) TmpA[j] = A[j];&#125;void Merge_Sort (ElementType A[], int N)&#123; int length; ElementType *TmpA; length = 1; TmpA = malloc(N*sizeof(ElementType)); if (TmpA !=NULL)&#123; while(length &lt;N)&#123; Merge_pass(A, TmpA, N, length); length *=2; Merge_pass(TmpA, A, N, length); length *=2; &#125; free(TmpA); &#125; else printf(\"空间不足\");&#125;","categories":[],"tags":[]},{"title":"数据结构-图","slug":"数据结构-图","date":"2019-11-26T06:36:38.000Z","updated":"2019-11-26T06:36:38.000Z","comments":true,"path":"2019/11/26/数据结构-图/","link":"","permalink":"http://yoursite.com/2019/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/","excerpt":"","text":"图 在程序里表示图邻接矩阵 G[N] [N]， N个顶点从0到N-1编号 对于无向图的存储，怎么样可以省一半空间 ​ 对于网络，只要把G[i] [j] 的值定义为边&lt;Vi, Vj&gt;的权重即可。 优点 直观简单 方便检查任意一对顶点间是否存在边 方便找任一顶点的所有“邻接点” 方便计算任一顶点的“度”（从该点发出的边数为“出度”，指向该点的边数“出度”） 无向图：对应行（或列）非0元素的个数 有向图：对应行非0元素的个数是“出度”；对应列非0元素的个数是“入度” 缺点 浪费空间（稀疏图） 浪费时间（稀疏图） 邻接表G[N]为指针数组， 对应矩阵每行一个链表，只存非0元素","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"数据结构-哈夫曼树","slug":"哈夫曼树与哈夫曼编码","date":"2019-11-25T15:34:24.000Z","updated":"2019-11-25T15:34:24.000Z","comments":true,"path":"2019/11/25/哈夫曼树与哈夫曼编码/","link":"","permalink":"http://yoursite.com/2019/11/25/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/","excerpt":"","text":"哈夫曼树 定义 e.g. 构造每次选权值最小的两棵树合并 123456789101112131415161718192021typedef struct TreeNode *HuffmanTree;struct TreeNode&#123; int Weight; HuffmanTree Left, Right;&#125;HuffmanTree Huffman (MinHeap H)&#123; // int i, HuffmanTree T; BuildMinHeap(H); for(i=1; i&lt;H-&gt;Size; i++)&#123; T = malloc(sizeof(struct TreeNode)); T-&gt;Left = DeleteMin(H); T-&gt;Right = DeleteMin(H); T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight; Insert(H,T); &#125; T = DeleteMin(H); return T;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"树","slug":"树","permalink":"http://yoursite.com/tags/%E6%A0%91/"}]},{"title":"数据结构练习 一元多项式的加法与乘法","slug":"数据结构练习-一元多项式的加法与乘法","date":"2019-11-21T15:11:58.000Z","updated":"2019-11-21T15:11:58.292Z","comments":true,"path":"2019/11/21/数据结构练习-一元多项式的加法与乘法/","link":"","permalink":"http://yoursite.com/2019/11/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%8A%A0%E6%B3%95%E4%B8%8E%E4%B9%98%E6%B3%95/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"PAT-B 1033 旧键盘打字","slug":"PAT-B-1033-旧键盘打字","date":"2019-11-21T14:56:45.000Z","updated":"2019-11-21T15:21:23.852Z","comments":true,"path":"2019/11/21/PAT-B-1033-旧键盘打字/","link":"","permalink":"http://yoursite.com/2019/11/21/PAT-B-1033-%E6%97%A7%E9%94%AE%E7%9B%98%E6%89%93%E5%AD%97/","excerpt":"","text":"旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？ 输入格式：输入在 2 行中分别给出坏掉的那些键、以及应该输入的文字。其中对应英文字母的坏键以大写给出；每段文字是不超过 105 个字符的串。可用的字符包括字母 [a-z, A-Z]、数字 0-9、以及下划线 _（代表空格）、,、.、-、+（代表上档键）。题目保证第 2 行输入的文字串非空。 注意：如果上档键坏掉了，那么大写的英文字母无法被打出。 输出格式：在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。 输入样例：127+IE.7_This_is_a_test. 输出样例：1_hs_s_a_tst 我的解答：12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int search(char c, char *huai)&#123; for(int i=0; huai[i];i++) &#123; if(huai[i]==c) return 1; &#125; return 0;&#125;int main()&#123; char huai[100]; char a[100010]; scanf(\"%s %s\",huai,a); int b; int flag = search('+',huai); for(int i=0;a[i];i++) &#123; if(a[i]&lt;='Z'&amp;&amp;a[i]&gt;='A' &amp;&amp; flag) b=0; //不打印 else if(!search(toupper(a[i]),huai))&#123; printf(\"%c\",a[i]); &#125; &#125;&#125; 第三个测试点报错： 第一行可以是空的。 大佬： 利用 ASCII 记录键盘的损坏与否 无法输出有两种情况：（键盘本身损坏）||（输出大写字母 &amp;&amp; 上档键损坏） 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int keyboard[128] = &#123;0&#125;; char ch; while((ch = getchar()) != '\\n')&#123; keyboard[toupper(ch)] = -1; &#125; while((ch = getchar()) != '\\n')&#123; if((keyboard[toupper(ch)]==-1) || (isupper(ch) &amp;&amp; keyboard['+' - '\\0']==-1))&#123; continue; &#125; putchar(ch); &#125; putchar('\\n'); return 0;&#125; 大佬2：123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;string.h&gt;#include&lt;stdio.h&gt;const int useless =-1;int main()&#123;//--------------------------------------------------- char a[110000]=&#123;&#125;,b[110000]=&#123;&#125;;//养成良好初始化的习惯 int hash[128]=&#123;0&#125;,lena,lenb;//ASCII代码一共有128个 gets(a); //一定要注意第一行未空行的情况，这里用cin和scanf都不能读取回车键，只能用gers() //不然中间会有一个测试点无法通过 gets(b); //这里你用scanf或者gets()都没问题 lena=strlen(a);//获取字符串a、b的长度 lenb=strlen(b);//--------------------------------------------------- for(int i=0;i&lt;lena;i++)&#123; if(a[i]=='+')&#123;//如果换挡失效 hash[a[i]]=useless;//那么加号失效 for(int j='A';j&lt;='Z';j++)&#123; hash[j]=useless;//并且所有的大写都失效 &#125; continue;//进入下一轮的循环 &#125; if(a[i]&lt;='Z'&amp;&amp;a[i]&gt;='A')&#123; hash[a[i]]=useless;//使大写失效 //上面这一句不可以省略不然最后一测试点会无法通过 hash[a[i]+-'A'+'a']=useless; //使小写失效 &#125; else&#123;//这里是数字或者其他字符的情况 hash[a[i]]=useless; &#125; &#125;//--------------------------------------------------- for(int i=0;i&lt;lenb;i++)&#123; if(hash[b[i]]!=useless) printf(\"%c\",b[i]); //输出所有尚未失效的字符 &#125;//--------------------------------------------------- printf(\"\\n\");//最后输出换行 return 0;&#125;","categories":[],"tags":[{"name":"PAT","slug":"PAT","permalink":"http://yoursite.com/tags/PAT/"}]},{"title":"数据结构-树","slug":"数据结构-树","date":"2019-11-17T06:08:44.000Z","updated":"2019-11-23T03:29:49.375Z","comments":true,"path":"2019/11/17/数据结构-树/","link":"","permalink":"http://yoursite.com/2019/11/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/","excerpt":"","text":"背景查找（Searching） 静态查找顺序查找123456789101112131415161718192021222324typedef struct LNode *List;struct LNode&#123; ElementType Element[max]; int Length;&#125;//哨兵技巧int SquentialSearch (List Tb1, ElementType K)&#123; int i; Tb1-&gt;Element[0] = K; //建立哨兵 for(i=Tb1-&gt;Length; Tb1-&gt;Element[i]!=K; i--); return i; //建立哨兵可在循环时减少一个判断的分支&#125;//无哨兵：int SequentialSearch (List Tb1, ElementType K)&#123; //在Element[1]~Element[n]中查找关键字为K的元素 int i; for(i=Tb1-&gt;length; i&gt;0 &amp;&amp; Tbl -&gt; Element[i]!=K; i--); return i; //查找成功返回下标，不成功返回0&#125; 时间复杂度： O(n) 二分查找(Binart Search) 123456789101112131415161718int BinarySearch (List Tbl, ElementType K)&#123; int left, right, mid, NoFound= -1; left =1; //左边界 right = Tbl -&gt;length; //右边界 while(left &lt;= right) &#123; mid = (left+right)/2; if(K &lt; Tbl-&gt;Element[mid]) right = mid-1; else if(K &gt; Tbl-&gt;Element[mid]) left = mid+1; else return mid; &#125; return NotFound;&#125; 树树的定义 树的表示儿子兄弟表示法 二叉树定义 特殊二叉树 二叉树重要性质二叉树的抽象数据类型定义 二叉树存储结构顺序存储结构 完全二叉树：按从上至下，从左到右顺序存储n个结点的完全二叉树的结点父子关系 非根结点（i&gt;1）的父结点的序号是 i/2 结点 i 的左孩子的结点序号是2i （若2i&lt;=n，否则没有左孩子） 结点 i 的右孩子的结点序号是2i+1 （若2i&lt;+1=n，否则没有左孩子） 一般二叉树： 也可以，但会空间浪费 链表存储1234567typedef struct TreeNode *BinTree;typedef BinTree Position;struct TreeNode&#123; ElementType Data; BinTree Left; BinTree Right;&#125; 二叉树的遍历先序遍历 访问根节点 先序遍历其左子树 先序遍历其右子树 123456789void PreOrderTraversal (BinTree BT)&#123; if(BT)&#123; printf(\"%d\",BT-&gt;Data); PreOrderTraversal(BT-&gt;Left); PreOrderTraversal(BT-&gt;Right); &#125;&#125;A B D F E C G H I 中序遍历 中序遍历其左子树 访问根节点 中序遍历其右子树 123456789void InOrderTraversal (BinTree BT)&#123; if(BT) &#123; InOrderTraversal(BT-&gt;Left); printf(\"%d\",BT-&gt;Data); InOrderTraversal(BT-&gt;Right); &#125;&#125;D B E F A G H C I 后序遍历 后序遍历其左子树 后序遍历其右子树 访问根节点 123456789void PostOrderTraversal (BinTree BT)&#123; if(BT) &#123; PostOrderTraversal(BT-&gt;Left); PostOrderTraversal(BT-&gt;Right); printf(\"%d\",BT-&gt;Data); &#125;&#125;D E F B H G I C A 二叉树的非递归遍历中序遍历非递归算法 遇到一个结点，把它压栈，并遍历它的左子树 当左子树遍历结束后，从栈顶弹出这个结点并访问它 按其又指针再去中序遍历该结点的右子树 12345678910111213141516void InOrderTraversal (BinTree BT)&#123; BinTree T = BT; Stack S = CreatStack(max); while(T || !IsEmpty(S))&#123; while(T)&#123; Push(S,T); T = T-&gt; Left; &#125; if (!IsEmpty(S))&#123; T = Pop(S); printf(\"%d\", T-&gt;Data); T = T-&gt;Right; &#125; &#125;&#125; 先序遍历的非递归遍历12345678910111213141516void PreOrderTraversal (BinTree BT)&#123; BinTree T = BT; Stack S = CreatStack(max); while(T||!IsEmpty(S))&#123; while(T)&#123; printf(\"%d\",T-&gt;Data); Push(S,T); T=T-&gt;Left; &#125; if (!IsEmpty(S))&#123; T = Pop(S); T = T-&gt;Right; &#125; &#125;&#125; 后序遍历的非递归遍历1https://www.icourse163.org/learn/ZJU-93001?tid=1207006212#/learn/content?type=detail&amp;id=1212031633&amp;cid=1215166204 层序遍历 队列实现：遍历从跟结点开始，首先将跟结点入列，然后开始执行循环：结点出队，访问该结点，其左右儿子入列。 1234567891011121314151617void LevelOrderTraversal (BinTree BT)&#123; Queue Q; BinTree T; if(!BT) return; Q = CreatQueue(max); AddQ(Q,BT); while(!IsEmptyQ(Q))&#123; T = DeleteQ(Q); printf(\"%d\\n\",T-&gt;Data); if(T-&gt;Left) AddQ(Q, T-&gt;Left); if(T-&gt;Right) AddQ(Q, T-&gt;Right); &#125;&#125; 二叉树遍历应用求二叉树高度 123456789101112int PostOrderGetHeight(BinTree BT)&#123; int HL, HR, MAXH; if(BT)&#123; HL=PostOrderGetHeight(BT-&gt;Left); HR=PostOrderGetHeight(BT-&gt;Right); MAXH = max(HL,HR); return (MAXH +1); &#125; else return 0;&#125; 二元运算表达树及其遍历 先序和中序遍历来确定一棵二叉树 二叉搜索树 主要功能搜索1234567891011Position Find(ElementType X, BinTree BST)&#123; if(!BST) return NULL; if(X&gt; BST-&gt;Data) return Find(X,BST-&gt;Right); else if(X &lt; BST-&gt;Data) return Find(X,BST-&gt;Left); else return BST;&#125; 非递归： 123456789101112Position IterFind(ElementType X, BinTree BST)&#123; while(BST)&#123; if(X&gt;BST-&gt;Data) BST = BST-&gt;Right; else if (X&lt;BST-&gt;Data) BST = BST-&gt;Left; else return BST; &#125; return NULL;&#125; 查找的效率取决了树的高度 插入1234567891011121314BinTree Insert(ElementType X, BinTree BST)&#123; if(!BST)&#123; BST = malloc(sizeof(struct TreeNode)); BST-&gt;Data = X; BST-&gt;Left = BST-&gt;Right = NULL; &#125;else&#123; if(X&lt;BST-&gt;Data) BST -&gt;Left = Insert(X,BST-&gt;Left); else if(X&gt;BST-&gt;Data) BST -&gt;Right = Insert(X,BST-&gt;Right); &#125; return BST;&#125; 删除 要删除的是叶节点 要删除的结点只有一个孩子：将其父结点的指着指向要删除结点的孩子结点 有左右两棵子树：用另一结点替代被删除结点：右子树的最小元素/左子树的最大元素 123456789101112131415161718192021222324BinTree Delete(ElementType X, BinTree BST)&#123; Posistion Tmp; if(!BST) printf(\"not found!\\n\"); else if(X&lt;BST-&gt;Data) BST -&gt;Left = Delete(X,BST-&gt;Left); else if(X&gt;BST-&gt;Data) BST -&gt;Right = Delete(X,BST-&gt;Right); else //找到了 if (BST-&gt;Left &amp;&amp; BST-&gt;Right)&#123; Tmp = FindMin(BST-&gt;Right); BST-&gt;Data = Tmp-&gt;Data; BST-&gt;Right = Delete(BST-&gt;Data, BST-&gt;Right); &#125; else&#123; Tmp = BST; if(!BST-&gt;Left) BST=BST-&gt;Right; else if(!BST-&gt;Right) BST=BST-&gt;Left; free (Tmp); &#125; return BST;&#125; 平衡二叉树 定义 “平衡因子，BF”：BF(T) = hL - hR 高度 设 nh 为高度为h的平衡二叉树的最少结点 （斐波那契数列相似） 平衡二叉树的调整12345678910111213//AVL树的旋转与插入typedef struct AVLNode * AVLTree; /* AVL树类型 */struct AVLNode&#123; ElementType Data; /* 结点数据 */ AVLTree Left; /* 指向左子树 */ AVLTree Right; /* 指向右子树 */ int Height; /* 树高 */&#125;;int Max ( int a, int b )&#123; return a &gt; b ? a : b;&#125; 12345678910AVLTree SingleRightRotation(AVLTree A)&#123; ALVTree B = A-&gt;Right; A-&gt;Right = B-&gt;Left; B-&gt;Left = A; A-&gt;Height = Max(GetHeight(A-&gt;Left),GetHeight(A-&gt;Right))+1; B-&gt;Height = Max(GetHeight(B-&gt;Left),A-&gt;Height)+1; return B;&#125; 12345678910AVLTree SingleLeftRotation(AVLTree A)&#123; AVLTree B = A-&gt;Left; A-&gt;Left = B-&gt;Right; B-&gt;Right = A; A-&gt;Height = Max(GetHeight(A-&gt;Left),GetHeight(A-&gt;Right))+1; B-&gt;Height = Max(GetHeight(B-&gt;Left),A-&gt;Height)+1; return B;&#125; 12345AVLTree DoubleLeftRightRotation ( AVLTree A )&#123; A-&gt;Left=SingleRightRotation(A-&gt;Left); return SingleLeftRotation(A);&#125; 12","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树","slug":"树","permalink":"http://yoursite.com/tags/%E6%A0%91/"}]},{"title":"PAT-B 1019数字黑洞","slug":"PAT-B-1019数字黑洞","date":"2019-11-08T13:02:49.000Z","updated":"2019-11-08T13:07:33.664Z","comments":true,"path":"2019/11/08/PAT-B-1019数字黑洞/","link":"","permalink":"http://yoursite.com/2019/11/08/PAT-B-1019%E6%95%B0%E5%AD%97%E9%BB%91%E6%B4%9E/","excerpt":"","text":"给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 6174，这个神奇的数字也叫 Kaprekar 常数。 例如，我们从6767开始，将得到 1234567766 - 6677 = 10899810 - 0189 = 96219621 - 1269 = 83528532 - 2358 = 61747641 - 1467 = 6174... ... 现给定任意 4 位正整数，请编写程序演示到达黑洞的过程。 输入格式：输入给出一个 (0,104) 区间内的正整数 N。 输出格式：如果 N 的 4 位数字全相等，则在一行内输出 N - N = 0000；否则将计算的每一步在一行内输出，直到 6174 作为差出现，输出格式见样例。注意每个数字按 4 位数格式输出。 输入样例 1：16767 输出样例 1：12347766 - 6677 = 10899810 - 0189 = 96219621 - 1269 = 83528532 - 2358 = 6174 输入样例 2：12222 输出样例 2：12222 - 2222 = 0000 我的题解：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int cmpup(const void * a, const void * b)&#123; return ( *(char*)a - *(char*)b );&#125;int cmpdown(const void * a, const void * b)&#123; return ( *(char*)b - *(char*)a );&#125;int main()&#123; char n[6]; char a[5],b[5]; int x=0,x1,i; scanf(\"%s\",n); char c= getchar(); //用来读取回车 if(strlen(n)!=4) &#123; for(i=strlen(n);i&lt;4;i++) n[i]='0'; &#125; while(x1!=6174)&#123; strcpy(a,n); strcpy(b,n); qsort(a,4,sizeof(char),cmpdown); qsort(b,4,sizeof(char),cmpup); if(strcmp(a,b)==0) &#123; printf(\"%s - %s = 0000\\n\",a,b); break; &#125; x = atoi(a)-atoi(b); printf(\"%s - %s = %d\\n\",a,b,x); x1=x; for(int i=3;i&gt;=0;i--) &#123; n[i]='0'+x%10; x=x/10; &#125; &#125;&#125;","categories":[],"tags":[{"name":"PAT-B","slug":"PAT-B","permalink":"http://yoursite.com/tags/PAT-B/"}]},{"title":"线性结构-队列","slug":"线性结构-队列","date":"2019-11-04T14:58:27.000Z","updated":"2020-10-31T12:52:29.242Z","comments":true,"path":"2019/11/04/线性结构-队列/","link":"","permalink":"http://yoursite.com/2019/11/04/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/","excerpt":"","text":"队列 结构12345678#define maxsizestruct QNode&#123; ElementType Data[maxsize]; int front; int rear; int maxsize; //&#125;typedef struct QNode *Queue; 初始化12345678Queue CreatQueue(int maxsize)&#123; Queue Q = (Queue)malloc(sizeof(struct QNode)); Q-&gt;Data = (ElementType *)malloc(MaxSize * sizeof(ElementType)); Q-&gt;Front = Q-&gt;Rear = 0; Q-&gt;MaxSize = MaxSize; return Q;&#125; 队列的顺序存储实现队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量front以及一个记录队列尾元素位置的变量rear组成。（rear和front初始都是-1） 顺环队列 问题：无法判断队列的空和满，空和满时 解决方案： 使用额外标记：Size或者tag 仅使用n-1个数组空间 (常用) 入队列12345678910void AddQ(Queue PtrQ, ElementType item)&#123; if((PtrQ-&gt;rear+1)%maxsize == PtrQ-&gt;front) &#123; printf(\"满\"); return; &#125; PtrQ-&gt;rear = (PtrQ-&gt;rear+1)%maxsize; PtrQ-&gt;Data[PtrQ-&gt;rear]=item;&#125; 出队列1234567891011ElementType DeleteQ(Queue PtrQ)&#123; if(PtrQ-&gt;front == PtrQ-&gt;rear) &#123; printf(\"空\"); return ERROR; &#125;else &#123; PtrQ-&gt;front = (PtrQ-&gt;front+1)%maxsize; return PtrQ-&gt;Data[PtrQ-&gt;front]; &#125;&#125; 队列的链式存储结构12345678910struct Node&#123; ElementType Data; struct Node *Next;&#125;;struct QNode&#123; struct Node *rear; //指向队尾结点 struct Node *front; //指向队头结点&#125;;typedef struct QNode *Queue;Queue PtrQ; 出队操作（不带头结点）123456789101112131415161718192021ElementType DeleteQ(Queue PtrQ)&#123; struct Node *FrontCell; ElementType FrontElem; if (PtrQ-&gt;front == NULL) &#123; printf(\"队列空\"); return ERROR; &#125; FrontCell = PtrQ-&gt;front; if(PtrQ-&gt;front == PtrQ-&gt;rear) PtrQ-&gt;front = PtrQ-&gt;rear = NULL; else PtrQ-&gt;front = PtrQ-&gt;front-&gt;Next; FrontElem = FrontCell -&gt; Data; free(FrontCell); return FrontElem;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"线性结构","slug":"线性结构","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"}]},{"title":"记乌镇戏剧节","slug":"记乌镇戏剧节","date":"2019-11-04T11:08:41.000Z","updated":"2019-11-04T11:08:41.928Z","comments":true,"path":"2019/11/04/记乌镇戏剧节/","link":"","permalink":"http://yoursite.com/2019/11/04/%E8%AE%B0%E4%B9%8C%E9%95%87%E6%88%8F%E5%89%A7%E8%8A%82/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"数据结构-堆栈","slug":"数据结构-堆","date":"2019-11-02T06:36:38.000Z","updated":"2019-11-02T06:36:38.000Z","comments":true,"path":"2019/11/02/数据结构-堆/","link":"","permalink":"http://yoursite.com/2019/11/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/","excerpt":"","text":"堆 优先队列: 特殊的“队列”， 取出元素的顺序是依照元素的优先权（关键字）大小。 堆的两个特性 结构性：用数组表示的完全二叉树。 有序性：任一结点的关键字是其子树所有结点的最大值（或最小值） “最大堆（MaxHeap）”， “大顶堆” “最小堆（MinHeap）”，“小顶堆” 堆的抽象数据类型描述 123456typedef struct HeapStruct *MaxHeap;struct HeapStruct &#123; ElementType *Elements; // 存储元素的数组 int Size; //当前元素个数 int Capacity; //堆的最大容量&#125; 创建空的最大堆12345678910MaxHeap Create(int maxsize)&#123; MaxHeap H = malloc(sizeof(struct HeapStruct)); H-&gt;Elements = malloc((maxsize+1)*sizeof(ElementType)); H-&gt;Size = 0; H-&gt;Capacity = maxsize; H-&gt;Elements[0] = MaxData; //哨兵元素，大于堆中所有元素 return H;&#125; 是否为空1234bool IsFull( MaxHeap H )&#123; return (H-&gt;Size == H-&gt;Capacity);&#125; 插入元素到最大堆12345678910111213bool Insert (MaxHeap H, ElementType item)&#123; int i; if (IsFull(H))&#123; printf(\"最大堆已满\"); return false; &#125; i = ++H-&gt;Size; // i指向插入后堆中的最后一个元素的位置 for( ;H-&gt;Elements[i/2] &lt; item; i/=2) H-&gt;Elements[i] = H-&gt;Elements[i/2];//上滤item H-&gt;Elements[i] = item; return true;&#125; 最大堆的删除123456789101112131415161718192021222324ElementType DeteleMax(MaxHeap H)&#123; /* 从最大堆H中取出键值为最大的元素，并删除一个结点 */ int Parent, Child; ElementType MaxItem , temp; if(IsEmpty(H))&#123; printf(\"最大堆已空\"); return; &#125; MaxItem = H-&gt;Elements[1]; temp = H-&gt;Elements[H-&gt;size--]; //temp为最后一个元素 for(Parent=1; Parent*2&lt;H-&gt;Size; Parent=Child)&#123; Child = Parent * 2; if((Child != H-&gt;size) &amp;&amp; (H-&gt;Elements[Child] &lt; H-&gt;Elements[Child+1])) Child++; if(temp &gt;= H-&gt;Elements[Child]) break; else H-&gt;Elements[Parent] = H-&gt;Elements[Child]; &#125; H-&gt;Elements[Parent] = temp; return MaxItem;&#125; 最大堆的建立 123456789101112131415161718void PerDown(MaxHeap H, int p)&#123; //下滤 int Parent, Child; ElementType X; X=H-&gt;Data[p]; for(Parent=p; Parent*2&lt;=H-&gt;Size; Parent=Child)&#123; Child = Parent * 2; if((Child!=H-&gt;Size)&amp;&amp;(H-&gt;Data[Child]&lt;H-&gt;Data[Child+1])) Child++; if(X&gt;=H-&gt;Data[Child]) break; else H-&gt;Data[Parent] = H-&gt;Data[Child]; &#125; H-&gt;Data[Parent] = X;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"线性结构","slug":"线性结构","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构-堆栈","slug":"数据结构-堆栈","date":"2019-11-01T06:36:38.000Z","updated":"2019-11-04T15:36:49.121Z","comments":true,"path":"2019/11/01/数据结构-堆栈/","link":"","permalink":"http://yoursite.com/2019/11/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86%E6%A0%88/","excerpt":"","text":"堆栈的抽象数据类型描述 栈的顺序存储实现1234567#define maxsizetypedef struct SNode *Stack;struct SNode&#123; ElementType Data[maxsize]; int Top&#125;;Stack Ptrs; 主要操作实现入栈1234567891011void Push(Stack PtrS, ElementType item)&#123; if(PtrS-&gt;Top == maxsize -1) &#123; printf(\"堆栈满\"); return; &#125;else&#123; PtrS-&gt;Data[++(PtrS-&gt;Top)] = item; return; &#125;&#125; 出栈12345678910ElementType Pop(Stack PtrS)&#123; if(PtrS-&gt;Top == -1) &#123; printf(\"堆栈空\"); return ERROR; //ERROR是特数值，标志错误 &#125; else return (PtrS-&gt;Data[(PtrS-&gt;Top)--]);&#125; 数组实现两个堆栈用一个数组实现两个堆栈，要求最大的利用数组空间，使数组只要有空间入栈操作就可以成功。 12345678#define maxsizestruct DStack&#123; ElementType Data[maxsize]; int Top1; //堆栈1的栈顶指针 int Top2; //堆栈2的栈顶指针&#125;S;S.Top1 = -1; // 在0里S.Top2 = maxsize; // 在maxsize-1外 入栈12345678910111213void Push(struct DStack *PtrS, ElementType item, int Tag)&#123; //Tag作为区分两个堆栈的标志 1 或 2 if (PtrS-&gt;Top2 - PtrS-&gt;Top1 ==1) &#123; printf(\"堆栈满\"); return ; &#125; if (Tag==1) PtrS -&gt; Data[++(PtrS-&gt;Top1)] = item; else PtrS -&gt; Data[--(PtrS-&gt;Top2)] = item; &#125; 出栈12345678910111213141516171819ElementType Pop(struct DStack *PtrS, int Tag)&#123; if (Tag==1) &#123; if(PtrS-&gt;Top1 == -1) &#123; printf(\"堆栈1空\"); return NULL; &#125; else return PtrS-&gt;Data[(PtrS-&gt;Top1)--]; &#125; else &#123; if (PtrS-&gt;Top2 == maxsize) &#123; printf(\"堆栈2空\"); return NULL; &#125; else return PtrS-&gt;Data[(PtrS-&gt;Top2)++]; &#125;&#125; 堆栈链式存实现栈的链式存储结构实际上就是一个单链表，叫做链栈。 插入和删除操作只能在链栈的栈顶进行。栈顶指针Top应该在链表的头部。 123456typedef struct SNode *Stack;struct SNode&#123; ElementType Data; struct SNode *Next;&#125;; 堆栈初始化1234567Stack CreateStack()&#123; //构建一个堆栈的头结点，返回指针 Stack S; S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Next = NULL; return S;&#125; 判断堆栈是否为空1234int IsEmpty(Stack S)&#123; return (S-&gt;Next == NULL);&#125; push12345678void Push (ElementType item, Stack S)&#123; struct SNode *TmpCell; TemCell=(struct SNode *)malloc(sizeof(Struct SNode)); TemCell-&gt;Data = item; TemCell-&gt;Next = S-&gt;Next; S-&gt;Next = TmpCell;&#125; pop12345678910111213141516ElementType Pop(Stack S)&#123; struct SNode *FirstCell; ElementType TopElem; if(IsEmpty(S)) &#123; printf(\"堆栈空\"); return NULL; &#125; else &#123; FirstCell = S-&gt;Next; S-&gt;Next = FirstCell-&gt;Next; TopElem = FirstCell-&gt;Element; free(FirstCell); return TopElem; &#125;&#125; 堆栈应用 表达式求值基本策略中缀表达式-&gt;后缀表达式 运算数相对顺序不变，遇到运算数即输出 运算符号顺序发生改变 需要存储“等待中”的运算符 将当前运算符与“等待中”的运算符比较 中缀-&gt;后缀 例子 堆栈其他应用 函数调用及递归实现 深度优先搜索 回溯算法","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"线性结构","slug":"线性结构","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"}]},{"title":"19-11-01 杂记","slug":"19-11-01-杂记","date":"2019-11-01T06:13:55.000Z","updated":"2019-11-01T06:17:52.694Z","comments":true,"path":"2019/11/01/19-11-01-杂记/","link":"","permalink":"http://yoursite.com/2019/11/01/19-11-01-%E6%9D%82%E8%AE%B0/","excerpt":"","text":"昨儿晚上睡觉前，室友突然发现，已经11月了，再过一个月，2019年就结束了。害，明年就都20岁了，一点都不像20岁的样子，离自己理想的自己差的还可远了呢。 最近把博客搞了出来，说实话技术含量不大，想往后学学能把每一个文件夹里的东西都给搞懂，再做些自己的东西吧。","categories":[{"name":"个人","slug":"个人","permalink":"http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"数据结构-广义表","slug":"数据结构-广义表","date":"2019-10-31T15:04:24.000Z","updated":"2019-11-01T06:36:06.617Z","comments":true,"path":"2019/10/31/数据结构-广义表/","link":"","permalink":"http://yoursite.com/2019/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%BF%E4%B9%89%E8%A1%A8/","excerpt":"","text":"结构123456789typedef struct GNode *GList;struct GNode&#123; int Tag; //标志域：0表示结点是单元素，1表示结点是广义表 union&#123; //子表指针域Sublist与单元素数据域Data复用 ElementType Data; GList SubList; &#125; URegion; GList Next; //指向后继结点&#125;; 多重链表 例子矩阵可以用二维数组表示，但二维数组表示有两个缺陷 数组大小要事先确认 对于“稀疏矩阵”，造成大量的存储空间浪费。 分析： 只存储矩阵非0元素项 结点的数据域：行坐标Row，列坐标Col，数值Value 每个结点通过两个指针域，把同行、同列串起来 行指针（向右指针） Right 列指针（向下指针） Down *term 4 5 7 *: 路口结点，四行五列七项非零项 用一个标识符Tag来区分头结点和非0元素结点 头结点的标识值为”Head”，矩阵非0元素结点的标识值为”Term”.","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"线性结构","slug":"线性结构","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"}]},{"title":"牛客网PAT-B练习 1002 NowCoder数列","slug":"牛客网PAT-B练习-1002-NowCoder数列","date":"2019-10-31T06:13:48.000Z","updated":"2019-10-31T06:21:12.434Z","comments":true,"path":"2019/10/31/牛客网PAT-B练习-1002-NowCoder数列/","link":"","permalink":"http://yoursite.com/2019/10/31/%E7%89%9B%E5%AE%A2%E7%BD%91PAT-B%E7%BB%83%E4%B9%A0-1002-NowCoder%E6%95%B0%E5%88%97/","excerpt":"题目描述12345NowCoder最近在研究一个数列：* F(0) = 7* F(1) = 11* F(n) = F(n-1) + F(n-2) (n≥2)他称之为NowCoder数列。请你帮忙确认一下数列中第n个数是否是3的倍数。","text":"题目描述12345NowCoder最近在研究一个数列：* F(0) = 7* F(1) = 11* F(n) = F(n-1) + F(n-2) (n≥2)他称之为NowCoder数列。请你帮忙确认一下数列中第n个数是否是3的倍数。 输入描述12输入包含多组数据。每组数据包含一个整数n，(0≤n≤1000000)。 输出描述12对应每一组输入有一行输出。如果F(n)是3的倍数，则输出“Yes”；否则输出“No”。 输入数据123456012345 输出数据123456NoNoYesNoNoNo 我的思路 为避免重复操作，先读入所有的数并找到最大值max，定义一个函数求出包含前max+1项的数组。 关于终止输入：每个数后面都有一个空格，当读入数据后没有空格时，则跳出while循环终止输入。 我的代码：（报错，原因未知） 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;void Nowcoder(int m, int *a)&#123; int i=0; for(i=0;i&lt;=m;i++) &#123; if (i==0) a[i]=7; else if (i==1) a[i]=11; else a[i]=a[i-1]+a[i-2]; &#125;&#125;int main()&#123; int a[10000]=&#123;0&#125;; int b[10000]; int n,i=0,max=-1; while(scanf(\"%d\",&amp;n)) &#123; b[i++]=n; if(b[i-1]&gt;max) max=b[i-1]; char ch; if ((ch=getchar())!=' ') break; &#125; Nowcoder(max,a); int j=i; for(i=0;i&lt;j;i++) &#123; if(a[b[i]]%3==0) printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125;&#125; 大佬思路1234567题目中的公式为F(n)=F(n-1)+F(n-2)模拟规律得:F(2)=F(1)+F(0)=11+7=18 可以整除F(3)=F(2)+F(1)=18*1+11*1 不可以被整除F(4)=F(3)+F(2)=18*2+11*1 不可以被整除F(5)=F(4)+F(3)=18*3+11*2 不可以被整除F(6)=F(5)+F(4)=18*5+11*3 可以整除以此类推可以发现数列最终是求11出现的个数即只要11出现3倍的时候才能被整除，正好n=2,6,10,14......能被3整除 即n%4==2的即可被3整除。 解法: 123456789101112#include &lt;stdio.h&gt;int main()&#123; int n; while (scanf(\"%d\", &amp;n) != EOF) &#123; if (n % 4 == 2) printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"PAT-B","slug":"PAT-B","permalink":"http://yoursite.com/tags/PAT-B/"}]},{"title":"数据结构-线性表","slug":"数据结构-线性表","date":"2019-10-30T15:34:24.000Z","updated":"2019-11-01T06:30:44.756Z","comments":true,"path":"2019/10/30/数据结构-线性表/","link":"","permalink":"http://yoursite.com/2019/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"线性表 线性表的抽象数据类型描述 线性表的顺序存储实现 123456789typedef struct LNode *List;struct LNode&#123; ElementType Data[max]; int Last;&#125;;struct LNode L;List PtrL; //访问下标为i的元素：L.Data[i] / PtrL -&gt; Data[i]//线性表的长度： L.Last+1 / PtrL-&gt;Last +1 主要操作实现初始化（建立空的顺序表）1234567List MakeEmpty()&#123; List PtrL; //list为指向结构的指针类型 PtrL = (List)malloc(sizeof(struct LNode)); PtrL -&gt; Last = -1; return PtrL;&#125; 查找12345678910int Find(ElementType X, List PtrL)&#123; int i = 0; while(i &lt;= PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i]!= X) i++; if(i &gt; PtrL-&gt;Last) return -1; //没找到 返回-1 else return i; //找到后 返回位置&#125; 插入 从后面开始挪 12345678910111213141516171819void Insert(ElementType X,int i, List PtrL)&#123; int j; if(PtrL-&gt;Last == maxsize -1) //空间已满 &#123; printf(\"表满\"); return; &#125; if (i&lt;1 || i&gt;PtrL-&gt;Last+2) //插入位置合法性 &#123; printf(\"位置不合法\"); return; &#125; for(j=PtrL-&gt;Last; j&gt;= i-1; j--) PtrL-&gt;Data[j+1] = PtrL-&gt;Data[j];//向后挪 PtrL-&gt;Data[i-1]=X; //新元素插入 PtrL-&gt;Last++; //Last指向最后元素 return;&#125; 删除（删除表的第i个位置上的元素） 12345678910111213void Delete(int i, List PtrL)&#123; int j; if(i&lt;1 || i&gt;PtrL-&gt;Last+1) &#123; printf(\"不存在第%d个元素\",i); return; &#125; for(j=i;j&lt;=PtrL-&gt;Last;j++) PtrL-&gt;Data[j-1]=PtrL-&gt;Data[j]; PtrL-&gt;Last--; return;&#125; 线性表的链式存储结构 1234567typedef struct LNode *List;struct LNode&#123; ElementType Data; List Next; //下一个序号&#125;;struct LNode L;List PtrL; 主要操作实现求表长把链表遍历一遍 123456789101112int Length(List PtrL)&#123; List p =PtrL; //p指向表的第一个结点 int j = 0; while(p) //p != NULL 时 &#123; p = p-&gt;Next; j++; //当前p指向的是第j个结点 &#125; return j;&#125;//时间复杂度：O(n) 查找 按序号查找：FindKth; 1234567891011121314List FindKth(int K, List PtrL)&#123; List p = PtrL; int i =1; while(p!=NULL &amp;&amp; i&lt;K) &#123; p = p-&gt;Next; i++; &#125; if (i==K) return p; else return NULL;&#125; 按值查找：Find 1234567List Find(ElementType X, List PtrL)&#123; List p = PtrL; while(p!=NULL &amp;&amp; p-&gt;Data != X) p = p-&gt;Next; return p;&#125; 插入（在i-1个结点后插入X） 1234567891011121314151617181920212223List Insert(ElementType X, int i, List PtrL)&#123; List p,s; if(i==1) //插在表头时 &#123; s = (List)malloc(sizeof(struct LNode)); s-&gt;Data = X; s-&gt;Next = PtrL; return s; //返回一个新的链表 &#125; p = FindKth(i-1,PtrL); if(p==NULL) &#123; printf(\"参数错\"); return NULL; &#125;else &#123; s=(List)malloc(sizeof(struct LNode)); s-&gt;Data = X; s-&gt;Next = p-&gt;Next; p-&gt;Next = s; return PtrL; &#125;&#125; 删除（删除链表第i个位置上的结点） （4）重要：free(s) 12345678910111213141516171819202122232425262728List Delete(int i,List PtrL)&#123; List p,s; if(i==1) &#123; s=PtrL; if(PtrL!=NULL) PtrL = PtrL-&gt;Next; else return NULL; free(s); return PtrL; &#125; p = findKth(i-1,PtrL); if(p==NULL) &#123; printf(\"第%d个结点不存在\",i-1); return NULL; &#125;else if(p-&gt;Next == NULL) &#123; printf(\"第%d个结点不存在\", i); &#125;else&#123; s = p-&gt;Next; p-&gt;Next = s-&gt;Next; free(s); return PtrL; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"线性结构","slug":"线性结构","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"}]}]}