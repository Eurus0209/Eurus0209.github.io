{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"会飞","url":"http://yoursite.com","root":"/"},"pages":[{"title":"Hi 我是会飞","date":"2019-10-31T02:38:14.000Z","updated":"2019-10-31T05:17:46.131Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"try"},{"title":"life","date":"2019-10-31T05:00:23.000Z","updated":"2019-10-31T05:01:20.465Z","comments":true,"path":"life/index.html","permalink":"http://yoursite.com/life/index.html","excerpt":"","text":""}],"posts":[{"title":"牛客网PAT-B练习 1002 NowCoder数列","slug":"牛客网PAT-B练习-1002-NowCoder数列","date":"2019-10-31T06:13:48.000Z","updated":"2019-10-31T06:21:12.434Z","comments":true,"path":"2019/10/31/牛客网PAT-B练习-1002-NowCoder数列/","link":"","permalink":"http://yoursite.com/2019/10/31/%E7%89%9B%E5%AE%A2%E7%BD%91PAT-B%E7%BB%83%E4%B9%A0-1002-NowCoder%E6%95%B0%E5%88%97/","excerpt":"题目描述12345NowCoder最近在研究一个数列：* F(0) = 7* F(1) = 11* F(n) = F(n-1) + F(n-2) (n≥2)他称之为NowCoder数列。请你帮忙确认一下数列中第n个数是否是3的倍数。","text":"题目描述12345NowCoder最近在研究一个数列：* F(0) = 7* F(1) = 11* F(n) = F(n-1) + F(n-2) (n≥2)他称之为NowCoder数列。请你帮忙确认一下数列中第n个数是否是3的倍数。 输入描述12输入包含多组数据。每组数据包含一个整数n，(0≤n≤1000000)。 输出描述12对应每一组输入有一行输出。如果F(n)是3的倍数，则输出“Yes”；否则输出“No”。 输入数据123456012345 输出数据123456NoNoYesNoNoNo 我的思路 为避免重复操作，先读入所有的数并找到最大值max，定义一个函数求出包含前max+1项的数组。 关于终止输入：每个数后面都有一个空格，当读入数据后没有空格时，则跳出while循环终止输入。 我的代码：（报错，原因未知） 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;void Nowcoder(int m, int *a)&#123; int i=0; for(i=0;i&lt;=m;i++) &#123; if (i==0) a[i]=7; else if (i==1) a[i]=11; else a[i]=a[i-1]+a[i-2]; &#125;&#125;int main()&#123; int a[10000]=&#123;0&#125;; int b[10000]; int n,i=0,max=-1; while(scanf(\"%d\",&amp;n)) &#123; b[i++]=n; if(b[i-1]&gt;max) max=b[i-1]; char ch; if ((ch=getchar())!=' ') break; &#125; Nowcoder(max,a); int j=i; for(i=0;i&lt;j;i++) &#123; if(a[b[i]]%3==0) printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125;&#125; 大佬思路1234567题目中的公式为F(n)=F(n-1)+F(n-2)模拟规律得:F(2)=F(1)+F(0)=11+7=18 可以整除F(3)=F(2)+F(1)=18*1+11*1 不可以被整除F(4)=F(3)+F(2)=18*2+11*1 不可以被整除F(5)=F(4)+F(3)=18*3+11*2 不可以被整除F(6)=F(5)+F(4)=18*5+11*3 可以整除以此类推可以发现数列最终是求11出现的个数即只要11出现3倍的时候才能被整除，正好n=2,6,10,14......能被3整除 即n%4==2的即可被3整除。 解法: 123456789101112#include &lt;stdio.h&gt;int main()&#123; int n; while (scanf(\"%d\", &amp;n) != EOF) &#123; if (n % 4 == 2) printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"PAT-B","slug":"PAT-B","permalink":"http://yoursite.com/tags/PAT-B/"}]},{"title":"数据结构-线性表","slug":"数据结构-线性表","date":"2019-10-30T15:34:24.000Z","updated":"2019-10-31T04:12:20.002Z","comments":true,"path":"2019/10/30/数据结构-线性表/","link":"","permalink":"http://yoursite.com/2019/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"线性表 线性表的抽象数据类型描述 线性表的顺序存储实现 123456789typedef struct LNode *List;struct LNode&#123; ElementType Data[max]; int Last;&#125;;struct LNode L;List PtrL; //访问下标为i的元素：L.Data[i] / PtrL -&gt; Data[i]//线性表的长度： L.Last+1 / PtrL-&gt;Last +1 主要操作实现 初始化（建立空的顺序表） 1234567List MakeEmpty()&#123; List PtrL; //list为指向结构的指针类型 PtrL = (List)malloc(sizeof(struct LNode)); PtrL -&gt; Last = -1; return PtrL;&#125; 查找 12345678910int Find(ElementType X, List PtrL)&#123; int i = 0; while(i &lt;= PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i]!= X) i++; if(i &gt; PtrL-&gt;Last) return -1; //没找到 返回-1 else return i; //找到后 返回位置&#125; 插入 从后面开始挪 12345678910111213141516171819void Insert(ElementType X,int i, List PtrL)&#123; int j; if(PtrL-&gt;Last == maxsize -1) //空间已满 &#123; printf(\"表满\"); return; &#125; if (i&lt;1 || i&gt;PtrL-&gt;Last+2) //插入位置合法性 &#123; printf(\"位置不合法\"); return; &#125; for(j=PtrL-&gt;Last; j&gt;= i-1; j--) PtrL-&gt;Data[j+1] = PtrL-&gt;Data[j];//向后挪 PtrL-&gt;Data[i-1]=X; //新元素插入 PtrL-&gt;Last++; //Last指向最后元素 return;&#125; 删除（删除表的第i个位置上的元素） 12345678910111213void Delete(int i, List PtrL)&#123; int j; if(i&lt;1 || i&gt;PtrL-&gt;Last+1) &#123; printf(\"不存在第%d个元素\",i); return; &#125; for(j=i;j&lt;=PtrL-&gt;Last;j++) PtrL-&gt;Data[j-1]=PtrL-&gt;Data[j]; PtrL-&gt;Last--; return;&#125; 线性表的链式存储结构 1234567typedef struct LNode *List;struct LNode&#123; ElementType Data; List Next; //下一个序号&#125;;struct LNode L;List PtrL; 主要操作实现 求表长 把链表遍历一遍 123456789101112int Length(List PtrL)&#123; List p =PtrL; //p指向表的第一个结点 int j = 0; while(p) //p != NULL 时 &#123; p = p-&gt;Next; j++; //当前p指向的是第j个结点 &#125; return j;&#125;//时间复杂度：O(n) 查找 按序号查找：FindKth; 1234567891011121314List FindKth(int K, List PtrL)&#123; List p = PtrL; int i =1; while(p!=NULL &amp;&amp; i&lt;K) &#123; p = p-&gt;Next; i++; &#125; if (i==K) return p; else return NULL;&#125; 按值查找：Find 1234567List Find(ElementType X, List PtrL)&#123; List p = PtrL; while(p!=NULL &amp;&amp; p-&gt;Data != X) p = p-&gt;Next; return p;&#125; 插入（在i-1个结点后插入X） 1234567891011121314151617181920212223List Insert(ElementType X, int i, List PtrL)&#123; List p,s; if(i==1) //插在表头时 &#123; s = (List)malloc(sizeof(struct LNode)); s-&gt;Data = X; s-&gt;Next = PtrL; return s; //返回一个新的链表 &#125; p = FindKth(i-1,PtrL); if(p==NULL) &#123; printf(\"参数错\"); return NULL; &#125;else &#123; s=(List)malloc(sizeof(struct LNode)); s-&gt;Data = X; s-&gt;Next = p-&gt;Next; p-&gt;Next = s; return PtrL; &#125;&#125; 删除（删除链表第i个位置上的结点） （4）重要：free(s) 12345678910111213141516171819202122232425262728List Delete(int i,List PtrL)&#123; List p,s; if(i==1) &#123; s=PtrL; if(PtrL!=NULL) PtrL = PtrL-&gt;Next; else return NULL; free(s); return PtrL; &#125; p = findKth(i-1,PtrL); if(p==NULL) &#123; printf(\"第%d个结点不存在\",i-1); return NULL; &#125;else if(p-&gt;Next == NULL) &#123; printf(\"第%d个结点不存在\", i); &#125;else&#123; s = p-&gt;Next; p-&gt;Next = s-&gt;Next; free(s); return PtrL; &#125;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}]}